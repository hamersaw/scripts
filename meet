#!/bin/bash

version="0.1.1"
usage="USAGE: $(basename $0) COMMAND
COMMAND:
    help                        display this help menu
    add <element> <title>       add an element at the desired location
    calendar [date]             print week (containing date) of events
    edit <element>              edit an existing element
    list [element]              list all elements
    move <element> <element>    move an element within the same level
    remove <element>            remove the specified element
    version                     display the application version

DATE_OPT:
    <date>
        ex. '2020-12-02'
    <date>/<starttime>/<endtime>
        ex. '2020-10-01/14:00:00/14:45:00'
    <startdate>/<starttime>/<endtime>/<dateinterval>/<enddate>
        ex. '2020-09-14/13:00:00/14:00:00/2weeks/2020-12-14'"

# load commands from element library
. element.sh

# initialize instance variables
datadir="$HOME/.local/share/meet"
gatefile="$datadir/gatefile"
levels=( "calendar" "event" "date" )

# if doesn't exist -> create base configuration files
[ ! -d "$datadir" ] && mkdir -p "$datadir"
[ ! -f "$gatefile" ] && touch "$gatefile"

print_element() {
    # initialize instance variables
    parent_id "$2"
    find_element "$parentid" 

    # get element attributes
    local index="${2##*.}"
    local uuid=$(head -n "$index" "$element" \
        | tail -n 1 | awk '{print $1}')
    local title=$(head -n "$index" "$element" \
        | tail -n 1 | awk '{$1=""; print substr($0,2)}')

    # compile tags
    local tags=()
    if [ -f "$datadir/$uuid.md" ]; then
        tags+=("note")
    fi

    tagstring=$(join_tags "${tags[@]}")

    # print element
    local indent=""
    for (( i=0; i<$1; i++ )); do
        local indent="    $indent"
    done

    echo "$indent$2$3 - $title $tagstring"

    id_level "$2"
    if [ "$(( $idlevel + 1 ))" -ge "${#levels[@]}" ]; then
        return # if element is leaf -> return
    fi

    # print children
    local count=1
    while read line; do
        print_element $(( $1 + 1 )) "$2.$count"
        local count=$(( count + 1 ))
    done <"$datadir/$uuid"
}

parse_date() {
    # split argument into fields
    IFS='/'
    read -r -a array <<< "$1"

    # ensure correct number of fields
    if (( "${#array[@]}" != 1 )) \
            && (( "${#array[@]}" != 3 )) \
            && (( "${#array[@]}" != 5 )); then
        return 1
    fi

    # parse meeting times
    startdate="${array[0]}"
    starttime="00:00:00"
    (( "${#array[@]}" >= 3)) && starttime="${array[1]}"

    meettimestart="$(date -d "$startdate $starttime" "+%s")"
    (( "$?" != 0 )) && return 1

    enddate="${array[0]}"
    endtime="23:59:59"
    (( "${#array[@]}" >= 3)) && endtime="${array[2]}"

    meettimeend="$(date -d "$enddate $endtime" "+%s")"
    (( "$?" != 0 )) && return 1

    # validate times
    (( "$meettimeend" < "$meettimestart" )) && return 1

    # set maxtime and deltatime
    if (( "${#array[@]}" == 5 )); then
        maxtime="$(date -d "${array[4]} 23:59:59" "+%s")"
        (( "$?" != 0 )) && return 1

        deltatime="${array[3]}"
    else
        maxtime="$meettimestart"
        deltatime="1day"
    fi
}

# execute command
case "$1" in
    add)
        # check argument length
        (( $# != 3 )) && echo "'add' requires two arguments" && exit 1

        # if leaf element -> parse date
        id_level "$2"
        if [ "$(( $idlevel + 1 ))" -ge "${#levels[@]}" ]; then
            parse_date "$3" 
            (( "$?" != 0 )) && echo "failed to parse date" && exit 1
        fi

        # add element
        uuid=$(tr -dc 'A-F0-9' < /dev/urandom \
            | dd status=none bs=1 count=32)
        add_element "$2" "$uuid" "$3"

        # if leaf element -> generate timestamps
        if [ "$(( $idlevel + 1 ))" -ge "${#levels[@]}" ]; then
            # if reoccuring -> compute subsequent dates
            while (( "$meettimestart" <= "$maxtime" )); do
                echo "$meettimestart $meettimeend $id" \
                    >> "$datadir/$uuid"

                # update dates with next interval
                startdate="$(date -d "$startdate+$deltatime" "+%Y-%m-%d")"
                enddate="$(date -d "$enddate+$deltatime" "+%Y-%m-%d")"

                meettimestart="$(date -d "$startdate $starttime" "+%s")"
                meettimeend="$(date -d "$enddate $endtime" "+%s")"
            done
        fi

        id_level "$2"
        echo "[+] added ${levels[$idlevel]} '$2' '$3'"
        ;;
    calendar)
        # check argument length
        (( $# > 3 )) && \
            echo "'calendar' requires at most two arguments" && exit 1

        # initailize instance variables
        if [[ ! -z "$2" ]]; then
            datestring="$2"
        else
            datestring="$(date +%Y-%m-%d)"
        fi

        # get first day of week
        dayofweek="$(date -d "$datestring" "+%u")"
        (( "$?" != 0 )) && exit 1

        dayofweek=$(( $dayofweek - 1 ))
        datestring="$(date -d "$datestring-$dayofweek days" "+%Y-%m-%d")"

        # iterate over week
        for i in $(seq 0 6); do
            starttime="$(date -d "$datestring 00:00:00" "+%s")"
            endtime="$(date -d "$datestring 23:59:59" "+%s")"

            # today iterate over the days
            echo "- $(date -d "@$starttime" "+%A, %B %d %Y")"

            # iterate over calendars
            calendarcount=1
            while read calendarline; do
                read -r -a calendararray <<< "$calendarline"

                # iteratve over events
                eventcount=1
                while read eventline; do
                    read -r -a eventarray <<< "$eventline"

                    # iterate over dates
                    datecount=1
                    while read dateline; do
                        read -r -a datearray <<< "$dateline"

                        # process each date
                        while read meetline; do
                            read -r -a meetarray <<< "$meetline"
                            meetingstart="${meetarray[0]}"
                            meetingend="${meetarray[1]}"
                            # check if meeting overlaps today
                            if (( "$starttime" <= "$meetingend" )) \
                                    && (( "$endtime" >= "$meetingstart" )); then
                                # print meeting information
                                meeting="$(echo "$eventline" \
                                    | awk '{$1=""; print substr($0, 2)}')"

                                startdate="$(date -d "@$meetingstart" "+%H:%M:%S")"
                                enddate="$(date -d "@$meetingend" "+%H:%M:%S")"

                                echo "    - $calendarcount.$eventcount.$datecount $meeting: $startdate - $enddate"
                            fi
                        done <"$datadir/${datearray[0]}"

                    datecount=$(( $datecount + 1 ))
                    done <"$datadir/${eventarray[0]}"

                    eventcount=$(( $eventcount + 1 ))
                done < "$datadir/${calendararray[0]}"

                calendarcount=$(( $calendarcount + 1 ))
            done < "$gatefile"

            datestring="$(date -d "$datestring+1 day" "+%Y-%m-%d")"
        done
        ;;
    edit)
        # check argument length
        (( $# != 2 )) && echo "'edit' requires one argument" && exit 1

        # validate element
        validate_id "$2"
        find_element "$2" 

        vim "$element.md"

        # if note file is empty -> remove
        if [[ ! -s "$element.md" ]]; then
            rm "$element.md"
        fi
        ;;
    help)
        echo "$usage"
        ;;
    list)
        # check argument length
        (( $# > 2 )) && \
            echo "'list' requires zero or one argument(s)" && exit 1

        if [[ $# != 2 ]]; then
            # if no element argument -> print all boards
            awk '{$1=""; print NR " - " substr($0,2)}' "$gatefile"
        else
            # ensure element exists
            validate_id "$2"
            find_element "$2" 

            print_element "0" "$2"
        fi
        ;;
    move)
        # check argument length
        (( $# != 3 )) && \
            echo "'remove' requires three arguments" && exit 1

        move_element "$2" "$3"

        id_level "$2"
        echo "[|] moved ${levels[$idlevel]} '$2' to '$3'"
        ;;
    remove)
        # check argument length
        (( $# != 2 )) && echo "'remove' requires one argument" && exit 1

        remove_element "$2"

        id_level "$2"
        echo "[-] removed ${levels[$idlevel]} '$2'"
        ;;
    version)
        echo "$version"
        ;;
    *)
        echo "$usage"
        exit 1
        ;;
esac
