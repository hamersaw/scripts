#!/bin/bash

USAGE="USAGE $(basename $0) [COMMAND]
COMMANDS:
    help                                display this menu
    (init | initialize)                 initialize scripter environment
    (mod | module) <SUBCOMMAND>         perform module operations
    (proc | process) <SUBCOMMAND>       perform process operations
    (var | variable) <SUBCOMMAND>       perform variable operations"

MODUSAGE="USAGE $(basename $0) (mod|module) [SUBCOMMAND]
SUBCOMMANDS:
    help                    display this menu
    list                    list available modules
    run <module-name>       run the specified module
    show <module-name>      show information on the specified module"

PROCUSAGE="USAGE $(basename $0) (proc|process) [SUBCOMMAND]
SUBCOMMANDS:
    clear                   untrack all current processes
    help                    display this menu
    kill <process-id>       terminate the specified process
    list                    list all processes
    show <process-id>       show information on the specified process"

VARUSAGE="USAGE $(basename $0) (var|variable) [SUBCOMMAND]
SUBCOMMANDS:
    clear                   unset all variables
    get <name>              retrieve the value for a specified variable
    help                    display this menu
    list                    list all set variables
    set <name> <value>      set the value for a specified variable
    unset <name>            unset the value for a specified variable"

# initialize instance variables
BASEDIR="$HOME/.$(basename $0)"
LOGDIR="$BASEDIR/log"
MODDIR="$BASEDIR/modules"
PROCFILE="$BASEDIR/procfile"
VARFILE="$BASEDIR/varfile"

PLFMT="%-15s%-30s%-20s%-5s\n"
PLDIVLEN=72
MLFMT="%-30s%-60s%-5s\n"
MLDIVLEN=100
# TODO - VLFMT

# define helper functions
get_json() {
    echo ${1//\'/\"} | python3 -c "import sys, json; \
        print(json.load(sys.stdin)['$2'])"
}

get_json_list() {
    echo ${1//\'/\"} | python3 -c "import sys, json; \
        print(json.load(sys.stdin)[$2])" 2>/dev/null
}

is_pid_running() {
    if ps -p $1 > /dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

# execute command
case "$1" in
    help)
        printf "$USAGE\n"
        exit 0
        ;;
    init|initialize)
        # create modules and log directories
        [ ! -d $MODDIR ] && mkdir -p $MODDIR
        [ ! -d $LOGDIR ] && mkdir -p $LOGDIR
        [ ! -f $PROCFILE ] && touch $PROCFILE
        [ ! -f $VARFILE ] && touch $VARFILE
        ;;
    mod|module)
        # execute subcommand
        case "$2" in
            help)
                printf "$MODUSAGE\n"
                exit 0
                ;;
            list)
                printf "$MLFMT" "name" "description" "background"
                printf "%.0s-" $(seq 1 $MLDIVLEN); printf "\n"

                # iterate over script json configuration files
                for CONFIGFILE in $(find $MODDIR -name "*.js"); do
                    RELATIVEPATH=${CONFIGFILE/$MODDIR/} # strip MODDIR
                    case $RELATIVEPATH in
                        /*)
                            # strip leading /
                            RELATIVEPATH="${RELATIVEPATH:1:${#RELATIVEPATH}-1}"
                            ;;
                    esac
                    NAME="${RELATIVEPATH%.*}" # strip file extension

                    JSON=$(cat $CONFIGFILE)
                    DESCRIPTION=$(get_json "$JSON" "description")
                    BACKGROUND=$(get_json "$JSON" "background")

                    printf "$MLFMT" "$NAME" "$DESCRIPTION" "$BACKGROUND"
                done
                ;;
            run)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'run' command requires one argument" && exit 1

                # check if module exists
                CONFIGFILE="$MODDIR/$3.js"
                [ ! -f $CONFIGFILE ] && echo "module '$3' does not exist" && exit 1

                # populate options 
                JSON=$(cat $CONFIGFILE)
                OPTIONS=$(get_json "$JSON" "options")
                
                COUNT=0
                OPTIONSTRING=""
                for (( ; ; )); do
                    # get next option in list
                    OPTION=$(get_json_list "$OPTIONS" "$COUNT")
                    if [ $? -eq 0 ]; then
                        NAME=$(get_json "$OPTION" "name")
                        REQUIRED=$(get_json "$OPTION" "required")

                        # retrieve value from variable store
                        VALUE=$($0 var get $NAME)
                        [ -z $VALUE ] && [ $REQUIRED = "true" ] && \
                            echo "required variable '$NAME' is not set" && exit 1

                        # append to OPTIONSTRING
                        if [ -z $OPTIONSTRING ]; then
                            OPTIONSTRING="$NAME=$VALUE"
                        else
                            OPTIONSTRING="$OPTIONSTRING;$NAME=$VALUE"
                        fi
                    else
                        break
                    fi

                    (( COUNT += 1 ))
                done

                # execute module
                EXTENSION=$(get_json "$JSON" "extension")
                MODULEFILE="$MODDIR/$3.$EXTENSION"

                BACKGROUND=$(get_json "$JSON" "background")
                case $BACKGROUND in
                    true)
                        # execute in background
                        PID="$RANDOM"
                        $MODULEFILE "$OPTIONSTRING" \
                            >$LOGDIR/$PID.log 2>&1 &

                        echo "$PID $! $(date +%Y.%m.%d-%H:%M) \
                            $3 $OPTIONSTRING" >> $PROCFILE
                        echo "executed as pid $PID"
                        ;;
                    false)
                        $MODULEFILE "$OPTIONSTRING"
                        ;;
                    *)
                        echo "module 'background' must be set to 'true' or 'false'"
                        exit 1
                        ;;
                esac

                ;;
            show)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'show' command requires one argument" && exit 1

                # check if module exists
                CONFIGFILE="$MODDIR/$3.js"
                [ ! -f $CONFIGFILE ] && \
                    echo "module '$3' does not exist" && exit 1

                cat $CONFIGFILE
                ;;
            *)
                printf "$MODUSAGE\n"
                exit 1
                ;;
        esac
        ;;
    proc|process)
        # execute subcommand
        case "$2" in
            clear)
                cat /dev/null > $PROCFILE
                rm $LOGDIR/*
                ;;
            help)
                printf "$PROCUSAGE\n"
                exit 0
                ;;
            kill)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'kill' command requires one argument" && exit 1

                # kill process
                cat $PROCFILE | grep "^$3 " | awk '{print $3}' | xargs kill
                ;;
            list)
                printf "$PLFMT" "pid" "name" "timestamp" "running"
                printf "%.0s-" $(seq 1 $PLDIVLEN); printf "\n"

                # iterate over PROCFILE
                while read LINE; do
                    ARRAY=($LINE)
                    RUNNING=$(is_pid_running ${ARRAY[1]})
                    printf "$PLFMT" "${ARRAY[0]}" \
                        "${ARRAY[3]}" "${ARRAY[2]}" "$RUNNING"
                done < $PROCFILE
                ;;
            show)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'show' command requires one argument" && exit 1

                LINE=$(cat $PROCFILE | grep "^$3 ")
                if [ ! -z "$LINE" ]; then
                    ARRAY=($LINE)
                    RUNNING=$(is_pid_running ${ARRAY[1]})

                    echo "{
    \"pid\" : \"${ARRAY[0]}\"
    \"ospid\" : \"${ARRAY[1]}\"
    \"name\" : \"${ARRAY[3]}\"
    \"timestamp\" : \"${ARRAY[2]}\"
    \"running\" : \"$RUNNING\"
    \"options\" : \"${ARRAY[4]}\"
}"
                fi
                ;;
            *)
                printf "$PROCUSAGE\n"
                exit 1
                ;;
        esac
        ;;
    var|variable)
        # execute subcommand
        case "$2" in
            clear)
                cat /dev/null > $VARFILE
                ;;
            get)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'get' command requires one argument" && exit 1

                # retrieve variable value if exists
                cat $VARFILE | grep "^$3 " | awk '{print $2}'
                ;;
            help)
                printf "$VARUSAGE\n"
                exit 0
                ;;
            list)
                printf "%-30s%-30s\n" "name" "value"
                echo "------------------------------------------------------------"
                cat $VARFILE | awk '{printf "%-30s%-30s\n", $1, $2}'
                ;;
            set)
                # check argument length
                (( $# != 4 )) && \
                    echo "the 'set' command requires two arguments" && exit 1

                # check if variable already exists
                cat $VARFILE | grep -q "^$3 " && \
                    echo "variable '$3' already exists" && exit 1

                # add 'VARIABLE' and 'VALUE' to VARFILE
                echo "$3 $4" >> $VARFILE
                sort -o $VARFILE $VARFILE
                ;;
            unset)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'unset' command requires one argument" && exit 1

                # remove row from VARFILE
                sed -i "/^$3/d" $VARFILE
                ;;
            *)
                printf "$VARUSAGE\n"
                exit 1
                ;;
        esac
        ;;
    *)
        printf "$USAGE\n"
        exit 1
        ;;
esac
