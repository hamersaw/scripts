#!/bin/bash

USAGE="USAGE $(basename $0) [COMMAND]
COMMANDS:
    help
    init | initialize
    mod | module
    proc | process
    var | variable"

MODUSAGE="USAGE $(basename $0) (mod|module) [COMMAND]
COMMANDS:
    help
    list
    run
    show"

PROCUSAGE="USAGE $(basename $0) (proc|process) [COMMAND]
COMMANDS:
    help
    kill
    list
    show"

VARUSAGE="USAGE $(basename $0) (var|variable) [COMMAND]
COMMANDS:
    clear
    get
    help
    list
    set
    unset"

# initialize instance variables
BASEDIR="$HOME/.$(basename $0)"
LOGDIR="$BASEDIR/log"
MODDIR="$BASEDIR/modules"
PROCESSFILE="$BASEDIR/processfile"
VARFILE="$BASEDIR/varfile"

# define helper functions
get_json() {
    echo ${1//\'/\"} | python3 -c "import sys, json; \
        print(json.load(sys.stdin)['$2'])"
}

get_json_list() {
    echo ${1//\'/\"} | python3 -c "import sys, json; \
        print(json.load(sys.stdin)[$2])" 2>/dev/null
}

is_pid_running() {
    if ps -p $1 > /dev/null; then
        echo "true"
    else
        echo "false"
    fi
}

# execute command
case "$1" in
    help)
        printf "$USAGE\n"
        exit 0
        ;;
    init|initialize)
        # create modules and log directories
        [ ! -d $MODDIR ] && mkdir -p $MODDIR
        [ ! -d $LOGDIR ] && mkdir -p $LOGDIR
        [ ! -f $PROCESSFILE ] && touch $PROCESSFILE
        [ ! -f $VARFILE ] && touch $VARFILE
        ;;
    mod|module)
        # execute subcommand
        case "$2" in
            help)
                printf "$MODUSAGE\n"
                exit 0
                ;;
            list)
                printf "%-30s%-60s%-5s\n" "name" "description" "background"
                echo "----------------------------------------------------------------------------------------------------"

                # iterate over script json configuration files
                for CONFIGFILE in $(find $MODDIR -name "*.js"); do
                    RELATIVEPATH=${CONFIGFILE/$MODDIR/} # strip MODDIR
                    case $RELATIVEPATH in
                        /*)
                            # strip leading /
                            RELATIVEPATH="${RELATIVEPATH:1:${#RELATIVEPATH}-1}"
                            ;;
                    esac
                    NAME="${RELATIVEPATH%.*}" # strip file extension

                    JSON=$(cat $CONFIGFILE)
                    DESCRIPTION=$(get_json "$JSON" "description")
                    BACKGROUND=$(get_json "$JSON" "background")

                    printf "%-30s%-60s%-5s\n" "$NAME" "$DESCRIPTION" "$BACKGROUND"
                done
                ;;
            run)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'run' command requires one argument" && exit 1

                # check if module exists
                CONFIGFILE="$MODDIR/$3.js"
                [ ! -f $CONFIGFILE ] && echo "module '$3' does not exist" && exit 1

                # populate options 
                JSON=$(cat $CONFIGFILE)
                OPTIONS=$(get_json "$JSON" "options")
                
                COUNT=0
                OPTIONSTRING=""
                for (( ; ; )); do
                    # get next option in list
                    OPTION=$(get_json_list "$OPTIONS" "$COUNT")
                    if [ $? -eq 0 ]; then
                        NAME=$(get_json "$OPTION" "name")
                        REQUIRED=$(get_json "$OPTION" "required")

                        # retrieve value from variable store
                        VALUE=$($0 var get $NAME)
                        [ -z $VALUE ] && [ $REQUIRED = "true" ] && \
                            echo "required variable '$NAME' is not set" && exit 1

                        # append to OPTIONSTRING
                        if [ -z $OPTIONSTRING ]; then
                            OPTIONSTRING="$NAME=$VALUE"
                        else
                            OPTIONSTRING="$OPTIONSTRING;$NAME=$VALUE"
                        fi
                    else
                        break
                    fi

                    (( COUNT += 1 ))
                done

                # execute module
                EXTENSION=$(get_json "$JSON" "extension")
                MODULEFILE="$MODDIR/$3.$EXTENSION"

                BACKGROUND=$(get_json "$JSON" "background")
                case $BACKGROUND in
                    true)
                        # execute in background
                        PID="$RANDOM"
                        $MODULEFILE "$OPTIONSTRING" \
                            >$LOGDIR/$PID.log 2>&1 &

                        echo "$PID $! $(date +%Y.%m.%d-%H:%M) \
                            $3 $OPTIONSTRING" >> $PROCESSFILE
                        echo "executed as pid $PID"
                        ;;
                    false)
                        $MODULEFILE "$OPTIONSTRING"
                        ;;
                    *)
                        echo "module 'background' must be set to 'true' or 'false'"
                        exit 1
                        ;;
                esac

                ;;
            show)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'show' command requires one argument" && exit 1

                # check if module exists
                CONFIGFILE="$MODDIR/$3.js"
                [ ! -f $CONFIGFILE ] && \
                    echo "module '$3' does not exist" && exit 1

                cat $CONFIGFILE
                ;;
            *)
                printf "$MODUSAGE\n"
                exit 1
                ;;
        esac
        ;;
    proc|process)
        # execute subcommand
        case "$2" in
            help)
                printf "$PROCUSAGE\n"
                exit 0
                ;;
            kill)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'kill' command requires one argument" && exit 1

                # kill process
                cat $PROCESSFILE | grep "^$3 " | awk '{print $3}' | xargs kill
                ;;
            list)
                printf "%-15s%-30s%-20s%-5s\n" "pid" "name" "timestamp" "running"
                echo "------------------------------------------------------------------------"

                # iterate over PROCESSFILE
                while read LINE; do
                    ARRAY=($LINE)
                    RUNNING=$(is_pid_running ${ARRAY[1]})
                    printf "%-15s%-30s%-20s%-5s\n" "${ARRAY[0]}" \
                        "${ARRAY[3]}" "${ARRAY[2]}" "$RUNNING"
                done < $PROCESSFILE
                ;;
            show)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'show' command requires one argument" && exit 1

                LINE=$(cat $PROCESSFILE | grep "^$3 ")
                if [ ! -z "$LINE" ]; then
                    ARRAY=($LINE)
                    RUNNING=$(is_pid_running ${ARRAY[1]})

                    echo "{
    \"pid\" : \"${ARRAY[0]}\"
    \"ospid\" : \"${ARRAY[1]}\"
    \"name\" : \"${ARRAY[3]}\"
    \"timestamp\" : \"${ARRAY[2]}\"
    \"running\" : \"$RUNNING\"
    \"options\" : \"${ARRAY[4]}\"
}"
                fi
                ;;
            *)
                printf "$PROCUSAGE\n"
                exit 1
                ;;
        esac
        ;;
    var|variable)
        # execute subcommand
        case "$2" in
            clear)
                rm $VARFILE
                touch $VARFILE
                ;;
            get)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'get' command requires one argument" && exit 1

                # retrieve variable value if exists
                cat $VARFILE | grep "^$3 " | awk '{print $2}'
                ;;
            help)
                printf "$VARUSAGE\n"
                exit 0
                ;;
            list)
                printf "%-30s%-30s\n" "name" "value"
                echo "------------------------------------------------------------"
                cat $VARFILE | awk '{printf "%-30s%-30s\n", $1, $2}'
                ;;
            set)
                # check argument length
                (( $# != 4 )) && \
                    echo "the 'set' command requires two arguments" && exit 1

                # add 'KEY' and 'VALUE' to VARFILE
                mv $VARFILE $VARFILE.tmp
                { echo "$3 $4"; cat $VARFILE.tmp; } | sort  > $VARFILE
                rm $VARFILE.tmp
                ;;
            unset)
                # check argument length
                (( $# != 3 )) && \
                    echo "the 'unset' command requires one argument" && exit 1

                # remove row from VARFILE
                mv $VARFILE $VARFILE.tmp
                cat $VARFILE.tmp | sed "/^$3*/d" > $VARFILE
                rm $VARFILE.tmp
                ;;
            *)
                printf "$VARUSAGE\n"
                exit 1
                ;;
        esac
        ;;
    *)
        printf "$USAGE\n"
        exit 1
        ;;
esac
